---
alwaysApply: true
---
## Project: Squad Tracker

- Companion app for airsoft days with live squad tracking, scores, and simple BLE device integration.

### Codebases
- Flutter mobile app (Android, iOS) in `PROJECTS/squad-tracker-flutter`.
- PlatformIO C++ firmware for ESP32 TTGO T-Display in `Documents/PlatformIO/Projects/Bluetooth communication`.

### Flutter Project Structure
#### Repository layout (pruned)
```
/(repo root)
├─ pubspec.yaml
├─ analysis_options.yaml
├─ README.md
├─ assets/
│  └─ images/
│     ├─ markers/
│     └─ soldiers/
├─ lib/
│  ├─ main.dart
│  ├─ models/
│  ├─ providers/
│  ├─ screens/
│  ├─ utils/
│  └─ widgets/
├─ android/
│  ├─ app/
│  ├─ gradle.properties
│  └─ ...
├─ ios/
│  ├─ Runner/
│  ├─ Flutter/
│  └─ ...
├─ macos/  linux/  windows/
├─ web/
├─ supabase/
│  └─ migrations/
└─ .cursor/
   └─ rules/
```

#### Directory purposes
- **lib**: Dart source
  - `main.dart`: application entrypoint and app-wide initialization
  - `models/`: domain models and data types
  - `providers/`: app state and services (e.g., `user_squad_location_service.dart`)
  - `screens/`: top-level UI screens/views
  - `widgets/`: reusable UI components (e.g., `squad_members_list.dart`, `user_session_row.dart`, `navigation.dart`)
  - `utils/`: shared helpers and utilities
- **assets/images**: static images (markers, soldiers, etc.) declared in `pubspec.yaml`
- **android**: native Android project; includes Mapbox token in `gradle.properties`
- **ios**: native iOS project; configuration via `Runner.xcconfig`
- **macos/linux/windows**: desktop platform shells
- **web**: Flutter web entry (`index.html`) and PWA manifest
- **supabase/migrations**: SQL migrations and database DDL

Notes:
- Generated/build artifacts (e.g., `build/`) and development dependencies (e.g., `node_modules/`) are excluded from the structure above.

### BLE Device (TTGO T-Display, ESP32)
- Connection: One user ↔ one device (optional). When a user connects to a device, the app stores the device ID to auto-connect on app start.
- Buttons (confirmed mapping):
  - Left button (BTN_B): increment user's kill count by 1.
  - Right button (BTN_A): toggle alive/dead. When toggled to dead, increment deaths by 1.
- Display shows:
  - User's current score: kills, deaths, current status.
  - Dynamic score and status of other squad members.
- GATT profile:
  - Service UUID: `6E400001-B5A3-F393-E0A9-E50E24DCCA9E`
  - RX Characteristic (write from app → device): `6E400002-B5A3-F393-E0A9-E50E24DCCA9E`
  - TX Characteristic (notify from device → app): `6E400003-B5A3-F393-E0A9-E50E24DCCA9E`
- Protocol (newline-terminated ASCII lines):
  - Device → App (TX notifications):
    - `DEVICE_CONNECTED`, `DEVICE_DISCONNECTED`
    - `OP <opId> BTN_A` (status toggle), `OP <opId> BTN_B` (kill increment)
  - App → Device (RX writes), within snapshot block:
    - `RESET_MEMBERS` (begin snapshot)
    - `MY_STATUS <alive|dead|...>`
    - `MY_KD <kills> <deaths>`
    - `MEM <name> <kills> <deaths>` (repeatable)
    - `SEQ <n>` (monotonic sequence)
    - `ACK <opId>` (acknowledge last processed op)
    - `EOT` (end; apply only if sequence increased)

### Supabase
- Auth: Magic link via Supabase and Resend.
- Status taxonomy used across UI: `Alive`, `Dead`, `Needs help`, `Needs medic`.
- Enum: `public.user_status` values: `ALIVE`, `DEAD`, `HELP`, `MEDIC` (default `ALIVE`).

#### Status Mapping (App ↔ DB ↔ Device)
- App UI strings → DB enum → Device protocol token
  - `Alive` → `ALIVE` → `alive`
  - `Dead` → `DEAD` → `dead`
  - `Needs help` → `HELP` → `help`
  - `Needs medic` → `MEDIC` → `medic`
- Casing: App uses Title Case for display, DB uses uppercase enum values, device protocol uses lowercase ASCII tokens.
- Device inputs: The device only emits button ops (`OP <id> BTN_A` to toggle alive/dead, `OP <id> BTN_B` to increment kills). It does not directly emit `help`/`medic`. Those statuses originate from the app.
- App → Device: `MY_STATUS <alive|dead|help|medic>` is always sent in lowercase within the snapshot block so the device can render status consistently.

#### Schema Details (provided DDL)
- `game_rules`
  - Columns: `id` (identity PK), `created_at`, `time_before_death` default 30, `time_before_respawn` default 10, `squad_id`.
  - Constraints: `game_rules_pkey` (PK id), `game_rules_squad_id_key` (UNIQUE squad_id).
  - FKs: `squad_id` → `squads.id` (ON UPDATE CASCADE, ON DELETE CASCADE).

- `roles`
  - Columns: `id` (identity PK), `created_at`, `name`.
  - Constraints: `roles_pkey` (PK id), `roles_name_key` (UNIQUE name).

- `scoreboard_current` (VIEW)
  - Purpose: Current game scoreboard (only where `squad_games.ended_at IS NULL`).
  - Columns: `squad_id`, `game_id`, `user_id`, `username`, `kills`, `deaths`, `user_status`, `respawn_available_at`.
  - Sources: join `squad_games sg` + `user_game_stats ugs` + `users u`.

- `squad_games`
  - Columns: `id` (bigserial PK), `created_at`, `started_at` default now(), `ended_at` nullable, `squad_id` (required), `host_user_id` nullable.
  - Constraints: `squad_games_pkey` (PK id), `ended_after_started` CHECK (ended_at null or >= started_at).
  - FKs: `host_user_id` → `users.id`, `squad_id` → `squads.id`.
  - Index: `one_active_game_per_squad` UNIQUE on `squad_id` WHERE `ended_at IS NULL`.

- `squads`
  - Columns: `id` (identity PK), `created_at`, `name`, `uuid` default `substring(md5(random()::text),1,6)`.
  - Constraints: `squads_pkey` (PK id), `squads_id_key` (UNIQUE id), `squads_uuid_key` (UNIQUE uuid).

- `user_game_stats`
  - Columns: `id` (bigserial PK), `game_id`, `user_id`, `kills` default 0, `deaths` default 0, `user_status` enum default `ALIVE`, `joined_at`, `last_status_change_at`, `respawn_available_at` nullable, `left_at` nullable.
  - Constraints: `user_game_stats_pkey` (PK id), `user_game_stats_unique` (UNIQUE game_id, user_id).
  - FKs: `game_id` → `squad_games.id` (ON DELETE CASCADE), `user_id` → `users.id`.

- `user_squad_locations`
  - Columns: `id` (identity PK), `created_at`, `updated_at` default now(), `user_id` default `auth.uid()` (required), `squad_id` (required), `longitude`, `latitude`, `direction`.
  - Constraints: `user_squad_locations_pkey` (PK id), uniques on `(id)`, `(user_id)`, `(user_id, squad_id)`.
  - FKs: `squad_id` → `squads.id` (ON UPDATE CASCADE, ON DELETE CASCADE), `user_id` → `users.id` (ON UPDATE CASCADE, ON DELETE CASCADE).
  - Trigger: `locations_updated_at` BEFORE UPDATE executes `extensions.moddatetime('updated_at')`.

- `user_squad_sessions`
  - Columns: `id` (identity), `created_at`, `user_id` default `auth.uid()` (required), `is_host`, `squad_id` (required), `is_active` default true, `updated_at`.
  - Constraints: `squad_sessions_pkey` composite PK `(id, user_id, squad_id)`.
  - FKs: `user_id` → `users.id` (ON UPDATE CASCADE, ON DELETE CASCADE), `squad_id` → `squads.id` (ON UPDATE CASCADE, ON DELETE CASCADE).
  - Triggers:
    - `handle_updated_at` BEFORE UPDATE executes `extensions.moddatetime('updated_at')`.
    - `user_squad_sessions_trigger` AFTER INSERT/DELETE/UPDATE executes `manage_user_squad_locations()`.
    - `user_squad_sessions_biu_host` BEFORE INSERT or UPDATE OF `is_active` executes `auto_assign_host_on_insert_update()`.
    - `user_squad_sessions_aud_host` AFTER UPDATE OF `is_active`, `is_host` OR DELETE executes `reassign_host_if_needed()`.
  - Host rules:
    - Hosts must be active. On deactivation, session is automatically demoted from host.
    - When the host leaves (deactivates or session deleted), transfer host to another active member if any (oldest by `created_at`).
    - When no members remain active, no host exists (none assigned).
    - When the next user joins/reactivates and there is no host, they become host automatically.
  - Indexes/constraints:
    - Unique partial index `uq_user_squad_sessions_one_active_host_per_squad` on `(squad_id)` WHERE `is_active = true AND is_host = true`.
    - CHECK constraint `host_must_be_active`: `is_host` implies `is_active`.

- `users`
  - Columns: `id` (uuid PK), `updated_at`, `username` (CHECK length ≥ 3), `full_name`, `avatar_url`, `main_role`, `main_color`.
  - Constraints: `profiles_pkey` (PK id).
  - FKs: `id` → `auth.users(id)` (ON UPDATE CASCADE, ON DELETE SET DEFAULT), `main_role` → `roles(name)` (ON UPDATE CASCADE, ON DELETE SET NULL).

#### RLS Policies (current)
- `roles`
  - SELECT: role `public`; qual: `true`.
- `squad_games`
  - SELECT: role `public`; qual: EXISTS user session in same squad and active:
    `(EXISTS (SELECT 1 FROM user_squad_sessions uss WHERE uss.squad_id = squad_games.squad_id AND uss.user_id = auth.uid() AND uss.is_active = true))`
- `squads`
  - INSERT: role `authenticated`; with_check: `true`.
  - SELECT: role `public`; qual: `true`.
  - UPDATE: role `authenticated`; qual + with_check: requester is host of the squad:
    `(EXISTS (SELECT 1 FROM user_squad_sessions WHERE user_squad_sessions.user_id = auth.uid() AND user_squad_sessions.is_host = true AND user_squad_sessions.squad_id = squads.id))`
- `user_game_stats`
  - SELECT: role `public`; qual: requester is active in the related squad game:
    `(EXISTS (SELECT 1 FROM (squad_games sg JOIN user_squad_sessions uss ON uss.squad_id = sg.squad_id) WHERE sg.id = user_game_stats.game_id AND uss.user_id = auth.uid() AND uss.is_active = true))`
- `user_squad_locations`
  - DELETE: role `public`; qual: `auth.uid() = user_id`.
  - INSERT: role `authenticated`; with_check: `true`.
  - SELECT: role `public`; qual: `true`.
  - UPDATE: role `authenticated`; qual + with_check: `auth.uid() = user_id`.
- `user_squad_sessions`
  - INSERT: role `authenticated`; with_check: `true`.
  - SELECT: role `public`; qual: `true`.
  - UPDATE: role `authenticated`; qual: `auth.uid() = user_id`.
  - UPDATE (host scope): role `authenticated`; qual + with_check: requester is active host in same squad:
    `((SELECT auth.uid()) IN (SELECT uss1.user_id FROM user_squad_sessions uss1 WHERE uss1.squad_id = user_squad_sessions.squad_id AND uss1.is_active = true AND uss1.is_host = true))`
- `users`
  - SELECT: role `public`; qual: `true` (two identical policies present).
  - INSERT: role `public`; with_check: `auth.uid() = id` (two identical policies present).
  - UPDATE: role `public`; qual: `auth.uid() = id` (two identical policies present).

Additional policies to enforce:
- `game_rules`
  - SELECT: role `public`; qual: requester is active in the same squad:
    `(EXISTS (SELECT 1 FROM user_squad_sessions uss WHERE uss.squad_id = game_rules.squad_id AND uss.user_id = auth.uid() AND uss.is_active = true))`
  - INSERT/UPDATE/DELETE: role `authenticated`; qual + with_check: requester is active host in the same squad:
    `((SELECT auth.uid()) IN (SELECT uss1.user_id FROM user_squad_sessions uss1 WHERE uss1.squad_id = game_rules.squad_id AND uss1.is_active = true AND uss1.is_host = true))`
- `scoreboard_current` (VIEW)
  - View executes with security invoker to respect underlying table RLS:
    `ALTER VIEW scoreboard_current SET (security_invoker = on);`

### Mobile App Screens (Flutter)
- Login (via magic link): Supabase + Resend.
- User: change name, color, role; disconnect.
- Squads: join/create squads; view members; see if a game is ongoing; invite users; leave squad; host-only: start game, kick user, reassign host.
- Map (Mapbox):
  - Shows members' locations with markers based on status (alive, dead, need medic/help).
  - Controls: center/follow user position.
  - Battle log: events (kills, deaths, status changes, joins/leaves).
  - Game timer when ongoing.
  - FABs → bottom sheets:
    - Members: list with score, status, distance, bearing; sorting by kills, K/D, distance.
    - Actions: toggle statuses (Died, Send help, Send medic). Untoggling returns to Alive. Increment kills. (Future: objective contributions.)
    - Location: currently disable geolocation.
- Tracker: scan BLE devices; connect to user's TTGO; persist device ID for auto-reconnect.

### Mapping/Keys
- Map provider: Mapbox.
- Android token: stored in `android/gradle.properties`; read at runtime (no `--dart-define`).
- iOS token: stored in Xcode config (e.g., `Runner.xcconfig`); read at runtime (no `--dart-define`).

### Gameplay Concepts
- Create squads; members set username, color, role.
- Configure game rules per squad/game.
- Start/stop games; create new ones.
- Track per-user/per-game stats: kills, deaths, status; show per-game scorecards.

### Roadmap / Future
- TTGO UI:
  - Show member list with distance, status, kills/deaths.
  - Compass-style view indicating direction to each member.
- App gameplay/config:
  - Add i18n in the whole app
  - Define flexible game modes for multiple scenarios.
  - Map editing for objectives and markers (spawn points, objectives, misc markers).
- Connectivity (later):
  - Explore switching/bridging between cellular data and LoRa for communications.

### Assumptions / To Clarify
- None currently.

### Maintenance
- **Keep this file updated** when project elements change:
  - Database schema changes (new tables, columns, constraints, triggers, views)
  - BLE protocol modifications (new message types, UUID changes)
  - App screen/feature additions or removals
  - New game modes or configuration parameters
  - TTGO firmware behavior changes
  - Mapbox token handling updates
  - Roadmap items completed or new ones added
- Update the "Assumptions / To Clarify" section as items are resolved.
- When providing new schema/RLS/enum details, update the relevant sections immediately.